#Node.js에서 프로세스 메모리 관리 방식

Node.js에서 프로세스 메모리 관리는 V8 자바스크립트 엔진의 가비지 컬렉션과 힙 메모리 관리 기법을 기반으로 이루어진다. 메모리 사용을 최적화하고 메모리 누수를 방지하기 위해 다양한 도구와 기법을 사용할 수 있으며, 객체 재사용, 클로저 사용 주의, 정기적인 메모리 릴리스 등의 최적화 기법을 통해 효율적인 메모리 관리를 할 수 있다.

---

## 1. 메모리 구조

Node.js 프로세스가 사용하는 메모리는 크게 다음과 같이 나뉜다.

1. **코드 영역(Code Segment)**
    - 실행 파일의 코드가 저장되는 영역이다.
2. **데이터 영역(Data Segment)**
    - 초기화된 전역 변수와 정적 변수가 저장되는 영역이다.
3. **힙 영역(Heap Segment)**
    - 동적 메모리 할당이 이루어지는 영역이다.
    - V8 엔진의 가비지 컬렉터가 힙 메모리 관리를 담당한다.
4. **스택 영역(Stack Segment)**
    - 함수 호출 시 매개변수와 지역 변수가 저장되는 영역이다.
    - Node.js는 단일 스레드로 동작하기 때문에, 스택 오버플로우에 유의해야 한다.

---

## 2. V8 엔진의 메모리 관리

Node.js의 메모리 관리는 주로 V8 엔진에서 이루어진다. V8은 자바스크립트 코드를 빠르게 실행하기 위해 다음과 같은 기법을 사용한다.

1. **가비지 컬렉션(Garbage Collection)**
    - V8 엔진은 주기적으로 불필요해진 객체를 메모리에서 해제한다.
    - **마이너 GC(Minor GC)**: 새 공간(New Space)에서 수행되며, 비교적 자주 발생한다.
    - **메이저 GC(Major GC)**: 오래된 공간(Old Space)에서 수행되며, 마이너 GC보다 횟수는 적지만 비용이 크다.
2. **힙 메모리 제한**
    - Node.js는 힙 메모리에 기본 제한을 둔다. `-max-old-space-size`와 `-max-semi-space-size` 플래그로 조정할 수 있다.
    - 64비트 시스템의 기본 힙 제한은 약 1.5GB, 32비트 시스템은 약 512MB 정도다.
    - 힙 사이즈가 너무 커지면 GC에 걸리는 시간이 길어지므로, 적절한 최적화와 분산 설계를 고려해야 한다.
3. **기타 공간**
    - 코드용 공간(Code Space), 대형 객체 공간(Large Object Space) 등 다양한 내부 공간이 있다.
    - 일반적으로는 New Space와 Old Space를 중심으로 동작한다.

---

## 3. 메모리 프로파일링과 디버깅

Node.js 애플리케이션의 메모리 사용을 확인하고 문제를 해결하기 위해 여러 도구를 사용할 수 있다.

1. **프로세스 메모리 사용 조회**
    - `process.memoryUsage()` 메서드를 사용하여 현재 프로세스의 메모리 사용량을 확인한다.
    - 반환되는 정보:
        - `rss(Resident Set Size)`: 프로세스가 실제로 차지하고 있는 전체 메모리
        - `heapTotal`: V8 힙의 전체 할당량
        - `heapUsed`: V8 힙에서 실제로 사용 중인 메모리
        - `external`: V8 외부에서 사용 중인 메모리
2. **Heap Snapshot**
    - `node --inspect` 플래그를 사용하여 디버깅 모드로 실행하고, Chrome DevTools에서 힙 스냅샷을 찍을 수 있다.
    - 힙 스냅샷을 통해 객체 그래프를 시각적으로 분석하고, 어떤 객체가 얼마나 메모리를 차지하는지 확인한다.
3. **메모리 누수 디버깅**
    - `node --inspect`로 실행한 뒤, Chrome DevTools나 VSCode 디버거를 사용하여 메모리 누수를 추적한다.
    - `heapdump`, `node-memwatch` 등 라이브러리를 사용하면 메모리 누수 분석이 한층 수월하다.
4. **GC 수동 호출(개발·디버깅 환경)**
    - `node --expose-gc` 옵션을 사용하여 `global.gc()` 함수를 직접 호출할 수 있다.
    - 프로덕션 환경에서는 권장되지 않지만, 디버깅 시에는 유용하다.

---

## 4. 메모리 관리 최적화 팁

Node.js 애플리케이션에서 메모리 사용을 줄이고 누수를 방지하기 위해 여러 기법을 활용할 수 있다.

1. **객체 재사용**
    - 반복적으로 생성되는 객체는 재사용하여 메모리 할당과 해제 비용을 줄인다.
    - 루프 내부에서 매번 객체를 새로 생성하지 말고, 미리 만들어 둔 객체에 값을 덮어쓰는 방식으로 최적화한다.
2. **클로저 사용 주의**
    - 클로저는 함수가 생성될 당시의 외부 변수 참조를 계속 유지한다.
    - 불필요하게 많은 외부 변수를 참조하거나, 중첩된 클로저를 남발하면 메모리 사용이 늘어난다.
3. **정기적인 메모리 릴리스**
    - 대규모 객체나 배열을 더 이상 사용하지 않을 때는 `null` 또는 `undefined`로 할당해, GC 대상이 되도록 한다.
    - 이벤트 리스너를 등록했다면 필요 없을 때 해제한다.
4. **메모리 누수 방지**
    - 글로벌 객체에 데이터를 계속 쌓아두면 누수가 발생하기 쉽다.
    - **WeakMap**, **WeakSet**을 사용하면 필요 없어진 객체가 GC에 의해 회수될 수 있으므로 유용하다.
5. **효율적인 데이터 구조 사용**
    - 큰 배열에는 TypedArray(Uint8Array, Float32Array 등)를 사용하는 것이 메모리에 이점이 있을 수 있다.
    - 빈번하게 JSON 객체를 직렬화·역직렬화한다면, 데이터 구조를 단순화하거나 캐싱 전략을 고려한다.
6. **비동기 작업 주의**
    - 비동기 콜백이나 프로미스 체인에서 생성된 객체를 적절히 해제한다.
    - 에러가 발생했을 때 올바른 예외 처리를 하지 않으면, 필요 없는 객체가 계속 남아 있을 수 있다.

---

## 5. 이벤트 루프와 메모리 사용

Node.js는 단일 스레드 이벤트 루프 모델을 사용한다. 이벤트 루프는 비동기 콜백, I/O 작업 등을 관리하는 핵심 요소로, 메모리 문제와도 깊은 관련이 있다.

1. **단일 스레드 구조**
    - 하나의 스레드가 모든 자바스크립트 코드를 실행하기 때문에, 메모리 누수가 발생하면 애플리케이션 전체 성능이 떨어진다.
2. **libuv와 비동기 I/O**
    - libuv 라이브러리를 통해 네트워크, 파일 I/O 등 비동기 작업이 처리된다.
    - 비동기 작업이 완료된 후 콜백이 스택에 올라와 실행되는데, 이 과정에서 불필요한 객체가 유지되지 않도록 주의한다.
3. **Blocking 코드 주의**
    - 메모리 누수만큼이나 블로킹 코드는 이벤트 루프 정체를 일으킨다.
    - 이벤트 루프가 돌지 못하면 GC도 적시에 수행되지 않을 수 있어, 전체 메모리 사용량이 일시적으로 치솟을 수 있다.

---

## 마무리

Node.js 애플리케이션은 V8 엔진의 가비지 컬렉션에 의존하며, 효율적으로 메모리를 관리하기 위해서는 힙 메모리 구조와 이벤트 루프 동작 원리를 함께 이해해야 한다. `process.memoryUsage()`나 힙 스냅샷과 같은 도구를 통해 메모리 상태를 자주 모니터링할 수 있으니까. 객체 재사용과 클로저 사용 최소화 등 기본적인 최적화 기법을 적용하면서 안정적인 서비스를 제공하자!