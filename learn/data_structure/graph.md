# 그래프 이론의 기초
그래프 이론은 오일러 경로, 강한 연결 요소(SCC), 단절점과 같은 복잡한 개념들을 포함하며, 매우 넓은 범위를 다루는 이론이다.

## 기본 개념
### 정점(Vertex)과 간선(Edge)
그래프를 구성하는 기본 단위는 **정점(Vertex)**으로, 이는 노드라고도 불린다. 정점은 더 이상 나눌 수 없는 객체로, 위치, 사람, 물건 등으로 표현될 수 있다. 정점은 "점"으로 시각화되며, 특정 위치나 개체를 나타낸다.

**간선(Edge)**은 이러한 정점들을 연결하는 선을 의미한다. 간선은 관계나 경로를 나타내며, 두 정점 사이의 연결을 표현한다.

예를 들어, 소셜 네트워크에서 친구 관계를 생각해보자:

- 내가 한 사람과 친구 관계를 맺는다고 가정하자. 나와 그 사람은 각각 하나의 정점이고, 우리 사이의 친구 관계는 간선이 된다.
- 내가 한 사람을 팔로우한다고 가정하자. 나와 그 사람은 정점이고, 내가 그 사람을 팔로우하는 행동은 간선이 된다. 
- 만약 그 사람이 나를 팔로우하지 않는다면, 이것은 **단방향 간선**이 된다. 이는 한쪽으로만 연결된, 즉 나만 그 사람의 소식을 따르는 일방적인 관계이다.
- 반면, 그 사람이 나를 팔로우한다면, 이는 **양방향 간선**이 된다. 서로가 팔로우하는 상태로, 두 정점 사이에 양방향으로 간선이 존재하게 된다.

### Indegree와 Outdegree
정점에서 나가는 간선을 outdegree라고 하며, 정점으로 들어오는 간선을 indegree라고 한다.

### 가중치(Weight)
**가중치(Weight)**는 두 정점 사이의 이동이나 연결에 필요한 비용을 의미한다. 예를 들어, 내가 A라는 사람을 팔로우하기 위해 특정 소셜 네트워크에서 5,000원을 지불해야 한다면, 나와 A 사이의 가중치는 5,000원이 된다.

이렇게 정점과 간선들로 이루어진 집합을 **그래프(Graph)**라고 부른다.

---
**그래프(Graph)** 를 코드로 표현할 때, 2가지 방법이 많이 사용된다. `인접 행렬` 과 `인접 리스트`가 그것이다.

## 인접 행렬(Adjacency Matrix)

인접 행렬은 그래프에서 정점과 간선의 관계를 2차원 배열로 나타내는 방법이다. 이 배열은 정사각형 모양이며, 각 요소는 0 또는 1의 값을 가진다. 0은 두 정점 사이에 간선이 없음을, 1은 간선이 있음을 나타낸다.

예를 들어, 아래와 같은 그래프를 보자:

```
A -- B
|    |
C    D

```

이 그래프를 인접 행렬로 표현하면 다음과 같다:

```cpp
bool adj[4][4] = {
    {0, 1, 1, 0},
    {1, 0, 0, 1},
    {1, 0, 0, 0},
    {0, 1, 0, 0}
};

```

위 코드에서 `adj[0][1]`은 1로 설정되어 있으며, 이는 A와 B가 연결되어 있음을 의미한다. 반면, `adj[1][2]`는 0으로, 이는 B와 C가 연결되지 않았음을 나타낸다.

### 인접 행렬의 특징

- **공간 복잡도:** O(V^2)
- **간선 존재 여부 확인 시간:** O(1)

인접 행렬은 그래프가 조밀할 때 효율적이며, 모든 정점 쌍에 대해 빠르게 간선 존재 여부를 확인할 수 있다.

---

## 인접 리스트(Adjacency List)

인접 리스트는 그래프의 정점과 간선의 관계를 리스트로 표현하는 방법이다. 각 정점은 연결된 다른 정점들의 리스트를 가진다.

예를 들어, 같은 그래프를 인접 리스트(예시는 vector)로 표현하면 다음과 같다:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> adj[4];
    adj[0].push_back(1); // A - B
    adj[0].push_back(2); // A - C
    adj[1].push_back(0); // B - A
    adj[1].push_back(3); // B - D
    adj[2].push_back(0); // C - A
    adj[3].push_back(1); // D - B

    for(int i = 0; i < 4; i++) {
        cout << i << " :: ";
        for(int j : adj[i]) {
            cout << j << " ";
        }
        cout << endl;
    }

    return 0;
}
```

출력 결과는 다음과 같다:

```
0 :: 1 2
1 :: 0 3
2 :: 0
3 :: 1
```

### 인접 리스트의 특징

- **공간 복잡도:** O(V + E)
- **간선 존재 여부 확인 시간:** O(V)

인접 리스트는 그래프가 희소할 때 메모리 사용 면에서 더 효율적이며, 간선의 수가 많지 않은 경우 유리하다.

---

### 인접 행렬과 인접 리스트의 비교

- **공간 복잡도:** 인접 행렬은 O(V^2)로, 정점의 수가 많아질수록 더 많은 메모리를 사용한다. 반면, 인접 리스트는 O(V + E)로, 간선의 수에 비례해 메모리를 사용한다.
- **간선 존재 여부 확인 시간:** 인접 행렬은 O(1)로 빠르지만, 인접 리스트는 O(V)로 상대적으로 느리다.
- **적합한 상황:** 인접 행렬은 그래프가 조밀할 때, 인접 리스트는 그래프가 희소할 때 더 적합하다.