# 운영체제 프로세스 메모리 할당과 동작 방식 (리눅스 기준)
    
리눅스는 프로세스의 메모리 관리는 가상 메모리와 페이징을 기반으로 이루진다고 한다. 코드(Text), 데이터, 힙, 스택 등 다양한 메모리 영역으로 나누어 관리된다. 동시에 동적 메모리 할당, 메모리 매핑, 페이지 테이블, TLB, 스와핑 등 다양한 기법이 사용되어 메모리 사용의 효율성과 안정성을 높이고 있다.

---

### 1. 프로세스 메모리 구조

리눅스 운영체제에서 프로세스는 다음과 같은 메모리 영역으로 나누어진다:

1. **코드 영역 (Text Segment)**:
- 실행 파일의 코드가 저장되는 영역.
- 실행 가능한 명령어들이 포함.
- 일반적으로 읽기 전용이며, 공유 가능하게 설정될 수 있다.
2. **데이터 영역 (Data Segment)**:
- 전역 변수와 정적 변수가 저장되는 영역.
- 초기화된 데이터와 초기화되지 않은 데이터로 구분.
    - 초기화된 데이터는 프로그램 시작 시 초기값이 할당된 변수.
    - 초기화되지 않은 데이터(BSS - Block Started by Symbol)는 프로그램 시작 시 0으로 초기화되는 변수들.
3. **힙 영역 (Heap)**:
- 동적으로 메모리를 할당받을 때 사용되는 영역.
- `malloc`, `calloc`, `realloc` 등의 함수로 메모리를 할당하고, `free` 함수로 해제.
- 프로그램 실행 중에 크기가 동적으로 변경될 수 있다.
4. **스택 영역 (Stack)**:
- 함수 호출과 관련된 지역 변수와 매개 변수가 저장되는 영역.
- 함수 호출 시마다 새로운 스택 프레임이 할당되며, 함수 종료 시 스택 프레임이 해제된.
- LIFO(Last In First Out) 방식으로 동작한다.
5. **메모리 매핑 영역 (Memory Mapped Segment)**:
- 공유 라이브러리와 파일 매핑에 사용되는 영역.
- `mmap` 시스템 호출을 통해 메모리 매핑이 이루어진다.

### 2. 프로세스 메모리 할당 방식

리눅스 운영체제는 다음과 같은 방식으로 프로세스에 메모리를 할당된다:

6. **가상 메모리 (Virtual Memory)**:
- 각 프로세스는 독립된 가상 메모리 공간을 갖는다.
- 가상 메모리는 실제 물리 메모리와 일대일 대응되지 않으며, 페이지 테이블을 통해 물리 메모리와 매핑된다.
- 가상 메모리를 통해 메모리 보호와 메모리 공간 확장이 가능하다.
7. **페이징 (Paging)**:
- 메모리를 고정 크기 블록(페이지)으로 나누어 관리.
- 가상 메모리 주소를 페이지 단위로 물리 메모리와 매핑하여 사용된다.
- 페이지 부재(Page Fault) 시 필요한 페이지를 디스크에서 메모리로 가져옴.
8. **메모리 매핑 (Memory Mapping)**:
- 파일이나 장치를 메모리에 매핑하여 사용됨.
- `mmap` 시스템 호출을 통해 파일을 메모리에 매핑하면, 파일의 내용이 메모리 주소 공간에 직접 대응한다.
9. **동적 메모리 할당 (Dynamic Memory Allocation)**:
- 프로세스 실행 중 필요에 따라 동적으로 메모리를 할당하고 해제.
- 힙 영역을 사용하여 동적 메모리를 관리.
- 메모리 단편화(Memory Fragmentation)를 방지하기 위해 다양한 메모리 할당 알고리즘이 사용된다.

### 3. 프로세스 메모리 관리

리눅스 운영체제는 다음과 같은 메모리 관리 기법을 사용:

10. **페이지 테이블 (Page Table)**:
- 가상 주소와 물리 주소 간의 매핑 정보를 저장.
- 각 프로세스마다 독립된 페이지 테이블이 존재.
11. **TLB (Translation Lookaside Buffer)**:
- 최근에 사용된 페이지 테이블 항목을 캐싱하여 주소 변환 속도를 향상시킴.
- 페이지 테이블 조회를 줄이기 위해 사용됨.
12. **스와핑 (Swapping)**:
- 메모리가 부족할 때, 사용하지 않는 페이지를 디스크로 내보내고 필요한 페이지를 메모리로 불러온다.
- 스와핑을 통해 효율적인 메모리 사용이 가능하다.
13. **커널 메모리 관리 (Kernel Memory Management)**:
- 커널은 다양한 자료 구조와 알고리즘을 사용하여 메모리를 효율적으로 관리.
- Slab Allocator, Buddy System 등이 사용된다.


## 리눅스/유닉스 계열에서 가상 메모리 현황을 확인하는 방법
    
리눅스/유닉스 계열 시스템에서 가상 메모리 현황을 확인하기 위해 다양한 명령어를 사용할 수 있다. `free`, `vmstat`, `top`, `htop`, `ps`, `pmap`, `/proc` 파일 시스템, `smem` 등의 도구를 통해 시스템의 메모리 사용량, 프로세스별 메모리 현황, 메모리 맵 등을 확인하고 분석할 수 있다. 이러한 도구들을 적절히 활용하면 시스템 성능 모니터링과 문제 해결에 큰 도움이 된다.(지금 당장은 몰라도 실무에서 필요할 것!!)

---

1️⃣  `free` 명령어는 시스템의 메모리 사용 현황을 요약

- 출력 결과에는 전체 메모리, 사용 중인 메모리, 여유 메모리, 버퍼/캐시 메모리 등이 포함
- `free -h`
    - `-h`: 사람이 읽기 쉬운 형식으로 출력 (KB, MB, GB 등).

2️⃣ `vmstat` 명령어는 시스템의 가상 메모리, 프로세스, I/O, CPU 활동 등을 종합적으로 출력

- 주기적으로 업데이트되는 통계를 제공하여 시스템의 성능 모니터링에 유용
- `vmstat 1 5`
    - `1`: 1초 간격으로 업데이트
    - `5`: 5번 업데이트 후 종료.

3️⃣ `top` 명령어는 실시간으로 시스템의 전체적인 성능 상태 출력

- CPU, 메모리 사용량, 각 프로세스의 상태 등을 실시간으로 모니터링
- `top`

4️⃣ `htop` 명령어는 `top` 명령어의 향상된 버전으로, 보다 직관적인 인터페이스를 제공

- 사용자가 더욱 쉽게 시스템 상태를 파악 가능
- `htop`

5️⃣ `ps` 명령어는 현재 실행 중인 프로세스 목록과 그들의 메모리 사용량 출력

- 양한 옵션을 사용하여 출력 형식을 제어 가능
- `ps aux --sort=-%mem`
    - `aux`: 모든 사용자의 모든 프로세스를 표시.
    - `-sort=-%mem`: 메모리 사용량 기준으로 내림차순 정렬.

6️⃣ `pmap` 명령어는 특정 프로세스의 메모리 맵을 출력

- 각 메모리 영역의 시작 주소, 크기, 유형 등을 확인 가능
- `pmap -x <PID>`
    - `<PID>`: 대상 프로세스의 ID.
    - `x`: 상세 정보를 포함하여 출력.

7️⃣  리눅스에서는 `/proc` 파일 시스템을 통해 다양한 시스템 정보를 확인 가능

- 메모리 관련 주요 파일
    - `/proc/meminfo`: 시스템의 메모리 사용 현황을 요약한 정보.
    - `/proc/<PID>/status`: 특정 프로세스의 상태 및 메모리 사용 정보를 포함한 다양한 정보.
    - `/proc/<PID>/smaps`: 특정 프로세스의 메모리 매핑 정보.

```bash
cat /proc/meminfo
cat /proc/<PID>/status
cat /proc/<PID>/smaps
```

8️⃣ `smem` 명령어는 프로세스별 메모리 사용량을 보다 자세히 출력

- 프로세스별 메모리 사용량을 요약하고, 공유 메모리를 정확히 계산하여 출력
- `smem -r`
    - `-r`: 메모리 사용량을 기준으로 내림차순 정렬.

## taskset 명령어 정리

### 개요
`taskset`은 리눅스에서 **프로세스의 CPU 코어 할당**을 제어하기 위해 사용되는 명령어이다. 이는 **CPU affinity**(프로세스가 실행될 수 있는 CPU 코어를 지정하는 것)를 설정하거나 확인하는 데 사용된다. 멀티코어 시스템에서 특정 프로세스를 특정 코어에 할당하여 성능을 최적화하거나 리소스를 효율적으로 관리할 때 유용하다.

### 주요 기능

1. **특정 CPU 코어에 프로세스 할당**
   - `taskset`을 사용하여 프로세스를 특정 CPU 코어에 할당할 수 있다.
   - 예시:
     ```bash
     taskset -c 0 ./myprogram
     ```
     이 명령어는 `myprogram`을 CPU 0번 코어에서만 실행하도록 설정한다.

2. **실행 중인 프로세스의 CPU 코어 변경**
   - 이미 실행 중인 프로세스의 CPU affinity를 변경할 수 있다.
   - 예시:
     ```bash
     taskset -cp 1 1234
     ```
     이 명령어는 PID 1234번 프로세스를 CPU 1번 코어에서만 실행되도록 변경한다.

3. **프로세스의 현재 CPU affinity 확인**
   - 특정 프로세스가 어느 CPU 코어에서 실행될 수 있는지 확인할 수 있다.
   - 예시:
     ```bash
     taskset -p 5678
     ```
     이 명령어는 PID 5678번 프로세스의 현재 CPU affinity를 표시한다.

4. **멀티코어 시스템에서의 성능 최적화**
   - CPU 집약적인 작업을 별도의 코어에 할당하여 성능을 최적화하거나, 특정 코어에 부담을 줄 수 있다. 예를 들어, 중요한 프로세스를 특정 코어에 고정하여 다른 작업으로 인한 지연을 줄이는 데 활용할 수 있다.

### 명령어 옵션

- **`-c`**: CPU 코어 번호를 지정한다. 여러 코어를 쉼표로 구분하여 지정할 수 있다.
- **`-p`**: 특정 프로세스의 PID를 지정하여, 해당 프로세스의 CPU affinity를 조회하거나 변경할 수 있다.
