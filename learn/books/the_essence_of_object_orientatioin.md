# 객체지향의 사실과 오해

### 서론

객체지향의 본질을 이해하기 위해 객체, 역할, 책임, 협력의 관점에서 객체지향을 탐구하는 것이 핵심이다. 객체지향의 핵심은 클래스나 상속이 아니라 객체들이 메시지를 주고받으며 협력하는 것이다.

---

## 1장: 협력하는 객체들의 공동체

#### 객체지향의 목표와 본질

- 객체지향의 목표는 현실 세계를 모방하는 것이 아니라, 새로운 세계를 창조하는 것이다.
- 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고, 객체를 이용해 시스템을 분할힌다.

#### 협력하는 사람들(객체)

- **역할**은 관련된 책임들의 집합이며, 여러 객체가 동일한 역할을 수행할 수 있다.
  - **협력**은 요청(request), 응답(response) 으로 이루어진다.
- 역할은 `대체 가능성(substitutable)`을 의미하며, 객체들은 역할에 적합한 책임을 된다.
- 책임을 수행하는 방법은 자율적으로 선택할 수 있다. -> `다형성(polymorphims)`
- 하나의 객체는 동시에 여러 역할을 수행할 수 있다.

#### 역할, 책임, 그리고 협력

- 객체들은 협력을 통해 기능을 구현하며, 이는 어떤 객체도 단독으로 존재하지 않음을 강조한다.
  - app 의 기능은 더 작은 책임으로 분할되고 책임은 적절한 역항를 수행할 수 있는 객체에 의해 수행된다.
  - 
- 객체는 다른 객체들과의 **협력**을 통해 더 큰 목적을 달성한다.
- 협력에 참여하는 객체들에게 적절한 역할과 책임을 부여해야 한다.

#### 협력 속에 객체

- 덕목 1 : 객체는 충분히 **협력적**이어야 한다. 

  - 다만, 명령에 따라 행동하는 것이 아니라. 요청에 응답한다는 것을 명심

- 덕목 2 : 객체가 충분히 **자율적**이어야 한다.
  
  - 객체는 공동의 목표(기능 구현)에 따라 협력 참여하지만, 스스로 결정과 판단을 내릴 수 있다.

- 객체 = 상태(state) + 행동(behavior) + 식별자(identity)

#### 객체의 자율성과 협력

- 객체는 자율적인 존재로, 자신의 상태와 행동을 책임진다.
- **자율성**은 객체의 내부와 외부를 명확히 구분함으로써 유지된다.
  - 객체가 무엇(what)을 하는지는 외부에서 알 수 있지만, 어떻게(how) 처리하는지 알 수 없다.
- 객체는 협력에 참여하기 위해 메시지를 수신하고, 어떻게 응답할지는 스스로 결정한다.
  - 메세지는 객체지향 세계의 유일한 의사소통 수단
  - 송신자(sender), 수신자(receiver)


## 2장: 이상한 나라의 객체들
> **`행동이 상태를 결정한다`**
### 객체의 특성
- 객체는 상태(state), 행동(behavior), 식별자(identity)를 가진 실체이다.
#### 상태
> `상태`: 객체의 현재 정보를 나타낸다. 
- 과거의 모든 행동을 알 필요 없이 현재 상태에 기반하여 행동할 수 있게 한다.
- `상태`는 근본적으로 복잡성을 완화하고 인지 과부하를 줄일 수 있다.
- 상태를 구성하는 모든 특징은 `프로퍼티(property)` 라고 한다.
  - `정적`이다
  - ex. 키, 위치, 음료의 양
  - `프로퍼티 값(property value)` 은 시간의 흐름에 따라 변경되므로 `동적`이다.
  - ex. 170cm, 문앞, 500ml
  - `프로퍼티(property)` = `링크(link)` + `속성(attribute)`
  - 객체와 객체 사이의 의미 있는 연결은 `링크(link)` 라고 한다.
  - 링크와 달리 단순 값은 `속성(attribute)`다.

#### 행동
> 객체가 수행하는 동작으로, 상태를 변경시키는 유일한 방법이다.
- 행동의 `부수 효과(side effect)`로 상태 변경 그러나, 행동의 결과는 기존의 상태에 의존적이며 상태를 이용해 서술할 수 있다.
- 다른 객체에서 온 메세지는 객체에게 행동을 유발한다.
  - 객체는 행동을 통해 다른 객체와 협력하므로 외부에 가시적이어야 한다.
  - 객체는 상태를 캡슐 안에 감춰둔다. 외부 노출 X

#### 식별자
> 객체를 다른 객체와 구별하는 고유한 값으로, 상태나 행동이 변하더라도 객체를 식별할 수 있게 한다.
- 두 값이 같으면 두 인스턴스는 동일한 것으로 판단한다면, 이러한 성질을 `동등성(equality)` 라고 한다.
- 식별자를 기반으로 객체가 같은지 판단한다면 이 성질은 `동일성(identical)` 이라고 한다.
- 식별자가 있는 객체 : `참조 객체(reference object)`, `엔티티(entity)` 
  - ex. Person, Company
- 식별자가 없는 객체 : `값 객체(value object)`
  - ex. Integer, Array

#### 행동이 상태를 결정한다
- 객체의 행동이 상태를 결정하며, 행동(협력)이 우선시 되어야 한다.
- 만약, 상태를 먼저 고려해서 객체를 설계하면,
  - 상태에 너무 집중하면 캡슐화가 약해지고, 객체들이 외부와 고립된다.
  - 객체의 재사용성이 저하된다.
- 즉, 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야할 책임이다.
- 참고 : `책임-주도 설계(Responsibility-Driven Design RDD)`
#### 캡슐화와 자율성
- 객체는 자신의 상태를 외부에 노출하지 않고, 행동을 통해서만 상태를 변경한다.
- 캡슐화는 객체의 자율성을 높이고, 협력을 단순하고 유연하게 만든다.
- 객체는 자율성을 가진 `의인화`된 존재라고 생각

### 은유
> 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 `은유(metaphor)`이다.
- 은유는 `표현적 차이(representational gap)` 또는 `의미적 차이(semantic gap)` 와 같다.
- 소프트웨어의 객체 이름을 실제 이름과 동일하게 하면 의미와 구조가 쉽게 예측이 된다.
  - 유지보수가 용이하다.
  - 따라서 현실 도메인의 이름을 객체에게 부여하라고 한다. 

## 3장: 타입과 추상화

### 추상화를 통한 복잡성 극복
- 추상화란 불필요한 부분을 무시함으로써 복잡성을 극복한다.
  - 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점을 버리는 일반화를 통해 단순하게 만든다.
  - 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것

### 객체지향과 추상화
> 객체지향 패러다임은 객체를 추상화하므로 현실의 복잡성을 극복한다.
-  객체들의 공통점을 기준으로 그룹으로 나누어 단순화하면 복잡성을 효과적으로 감소시킨다.
  - 객체들을 묶기 위한 그릇을 `개념(concept)` 이라고 한다.
  - 개념이 특정 객체에 적용됐을 때 객체를 `개념의 인스턴스(instance)`라고 한다.
- `분류(classification)`는 추상화를 위한 도구다

#### 개념의 세 가지 관점(ex. 이상한 나라의 앨리스)

- **심볼**: 개념의 간단한 이름이나 표현.
  - ex. 트럼프
- **내연**: 개념의 완전한 정의로, 객체가 그 개념에 속하는지 결정하는 데 도움을 준다.
  - ex. 몸이 납작하고 두 손과 두 발은 네모 귀퉁에 달려 있는 인물
- **외연**: 그 개념에 속하는 모든 객체들의 집합.
  - ex. 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트왕과 여왕

### 타입(Type)
- 타입은 근복적으로 개념과 동일하다. 물론 SW에서 그대로 적용하기 쉽지 않지만
- 타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과한 것이다.

### 객체의 행동이 타입을 정의한다
- 객체와 타입의 대한 조언
  - 객체의 타입은 내부 구현이 아닌, 객체가 수행하는 **행동**에 따라 결정된다.
  - 내부 구조는 다르지만 동일한 행동을 하는 객체들은 동일한 타입에 속할 수 있다.
  - 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 
  - 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.

### 다형성  
> 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력
- 동일한 책임을 수행하는 일련의 객체는 동일한 타입이다.
- 행동만 동일(같은 타입)하다면 서로 다른 데이터를 가질 수 있다.
- 다형성을 유지하기 위해 동일한 메시지를 수신할 수 있어야 한다.

### 캡슐화
- 객체지향 설계는 인터페이스 뒤에 행동과 상태를 캡슐화하여, 객체의 내부 구현이 변경되더라도 외부와의 상호작용에 영향을 주지 않도록 한다.
  - 그렇지 않으면 객체의 분류 체계는 빠르게 오염된다. 

### 타입의 계층
- `일반화(generalization)` : 일반적인 타입의 모음
  - ex. 트럼프 카드의 특징 : 납작 엎드릴 수 있음, 뒤집어질 수 있음
- `특수화(specialization)` : 일반적인 타입이 가진 모든 타입을 포함하지만, 거기에 더 해 자신만의 특수한 타입이 포함됨
  - ex 트럼프 카드 인간의 특징 : 걷기, 말하기
- 일반화와 특수화는 동시에 일어난다.
- 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있다.(리스코프 치환의 원칙)
- `슈퍼타입(Supertype)` = 일반적인 타입, `서브타입(Subtype)` = 특수한 타입

### 정적 모델
- 동적으로 변하는 객체의 복잡성을 극복하기 위해 타입을 사용한다.
  - 객체의 상태가 변경해도 식별성은 동일하게 유지된다.
  - ex. 타입 모델(type diagram)

### 동적 모델
- 객체의 상태를 스냅샷 처럼 포착하는 것
  - ex. UML의 객체 다이어그램(object diagram)

### 클래스(class)
- 객체지향에서 정적인 모델은 클래스를 이용해서 구현된다.
  - 가장 보편적인 방법 but 클래스가 타입과 동일하지 않다.
