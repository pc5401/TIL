# 객체지향의 사실과 오해

### 서론

객체지향의 본질을 이해하기 위해 객체, 역할, 책임, 협력의 관점에서 객체지향을 탐구하는 것이 핵심이다. 객체지향의 핵심은 클래스나 상속이 아니라 객체들이 메시지를 주고받으며 협력하는 것이다.

---

## 1장: 협력하는 객체들의 공동체

#### 객체지향의 목표와 본질

- 객체지향의 목표는 현실 세계를 모방하는 것이 아니라, 새로운 세계를 창조하는 것이다.
- 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고, 객체를 이용해 시스템을 분할힌다.

#### 협력하는 사람들(객체)

- **역할**은 관련된 책임들의 집합이며, 여러 객체가 동일한 역할을 수행할 수 있다.
  - **협력**은 요청(request), 응답(response) 으로 이루어진다.
- 역할은 `대체 가능성(substitutable)`을 의미하며, 객체들은 역할에 적합한 책임을 된다.
- 책임을 수행하는 방법은 자율적으로 선택할 수 있다. -> `다형성(polymorphims)`
- 하나의 객체는 동시에 여러 역할을 수행할 수 있다.

#### 역할, 책임, 그리고 협력

- 객체들은 협력을 통해 기능을 구현하며, 이는 어떤 객체도 단독으로 존재하지 않음을 강조한다.
  - app 의 기능은 더 작은 책임으로 분할되고 책임은 적절한 역항를 수행할 수 있는 객체에 의해 수행된다.
- 객체는 다른 객체들과의 **협력**을 통해 더 큰 목적을 달성한다.
- 협력에 참여하는 객체들에게 적절한 역할과 책임을 부여해야 한다.

#### 협력 속에 객체

- 덕목 1 : 객체는 충분히 **협력적**이어야 한다. 
  - 다만, 명령에 따라 행동하는 것이 아니라. 요청에 응답한다는 것을 명심
- 덕목 2 : 객체가 충분히 **자율적**이어야 한다.
  - 객체는 공동의 목표(기능 구현)에 따라 협력 참여하지만, 스스로 결정과 판단을 내릴 수 있다.
- 객체 = 상태(state) + 행동(behavior) + 식별자(identity)

#### 객체의 자율성과 협력

- 객체는 자율적인 존재로, 자신의 상태와 행동을 책임진다.
- **자율성**은 객체의 내부와 외부를 명확히 구분함으로써 유지된다.
  - 객체가 무엇(what)을 하는지는 외부에서 알 수 있지만, 어떻게(how) 처리하는지 알 수 없다.
- 객체는 협력에 참여하기 위해 메시지를 수신하고, 어떻게 응답할지는 스스로 결정한다.
  - 메세지는 객체지향 세계의 유일한 의사소통 수단
  - 송신자(sender), 수신자(receiver)


## 2장: 이상한 나라의 객체들
> **`행동이 상태를 결정한다`**
### 객체의 특성
- 객체는 상태(state), 행동(behavior), 식별자(identity)를 가진 실체이다.
#### 상태
> `상태`: 객체의 현재 정보를 나타낸다. 
- 과거의 모든 행동을 알 필요 없이 현재 상태에 기반하여 행동할 수 있게 한다.
- `상태`는 근본적으로 복잡성을 완화하고 인지 과부하를 줄일 수 있다.
- 상태를 구성하는 모든 특징은 `프로퍼티(property)` 라고 한다.
  - `정적`이다
  - ex. 키, 위치, 음료의 양
  - `프로퍼티 값(property value)` 은 시간의 흐름에 따라 변경되므로 `동적`이다.
  - ex. 170cm, 문앞, 500ml
  - `프로퍼티(property)` = `링크(link)` + `속성(attribute)`
  - 객체와 객체 사이의 의미 있는 연결은 `링크(link)` 라고 한다.
  - 링크와 달리 단순 값은 `속성(attribute)`다.

#### 행동
> 객체가 수행하는 동작으로, 상태를 변경시키는 유일한 방법이다.
- 행동의 `부수 효과(side effect)`로 상태 변경 그러나, 행동의 결과는 기존의 상태에 의존적이며 상태를 이용해 서술할 수 있다.
- 다른 객체에서 온 메세지는 객체에게 행동을 유발한다.
  - 객체는 행동을 통해 다른 객체와 협력하므로 외부에 가시적이어야 한다.
  - 객체는 상태를 캡슐 안에 감춰둔다. 외부 노출 X

#### 식별자
> 객체를 다른 객체와 구별하는 고유한 값으로, 상태나 행동이 변하더라도 객체를 식별할 수 있게 한다.
- 두 값이 같으면 두 인스턴스는 동일한 것으로 판단한다면, 이러한 성질을 `동등성(equality)` 라고 한다.
- 식별자를 기반으로 객체가 같은지 판단한다면 이 성질은 `동일성(identical)` 이라고 한다.
- 식별자가 있는 객체 : `참조 객체(reference object)`, `엔티티(entity)` 
  - ex. Person, Company
- 식별자가 없는 객체 : `값 객체(value object)`
  - ex. Integer, Array

#### 행동이 상태를 결정한다
- 객체의 행동이 상태를 결정하며, 행동(협력)이 우선시 되어야 한다.
- 만약, 상태를 먼저 고려해서 객체를 설계하면,
  - 상태에 너무 집중하면 캡슐화가 약해지고, 객체들이 외부와 고립된다.
  - 객체의 재사용성이 저하된다.
- 즉, 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야할 책임이다.
- 참고 : `책임-주도 설계(Responsibility-Driven Design RDD)`

#### 캡슐화와 자율성
- 객체는 자신의 상태를 외부에 노출하지 않고, 행동을 통해서만 상태를 변경한다.
- 캡슐화는 객체의 자율성을 높이고, 협력을 단순하고 유연하게 만든다.
- 객체는 자율성을 가진 `의인화`된 존재라고 생각

### 은유
> 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 `은유(metaphor)`이다.
- 은유는 `표현적 차이(representational gap)` 또는 `의미적 차이(semantic gap)` 와 같다.
- 소프트웨어의 객체 이름을 실제 이름과 동일하게 하면 의미와 구조가 쉽게 예측이 된다.
  - 유지보수가 용이하다.
  - 따라서 현실 도메인의 이름을 객체에게 부여하라고 한다. 

## 3장: 타입과 추상화

### 추상화를 통한 복잡성 극복
- 추상화란 불필요한 부분을 무시함으로써 복잡성을 극복한다.
  - 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점을 버리는 일반화를 통해 단순하게 만든다.
  - 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것

### 객체지향과 추상화
> 객체지향 패러다임은 객체를 추상화하므로 현실의 복잡성을 극복한다.
-  객체들의 공통점을 기준으로 그룹으로 나누어 단순화하면 복잡성을 효과적으로 감소시킨다.
  - 객체들을 묶기 위한 그릇을 `개념(concept)` 이라고 한다.
  - 개념이 특정 객체에 적용됐을 때 객체를 `개념의 인스턴스(instance)`라고 한다.
- `분류(classification)`는 추상화를 위한 도구다

#### 개념의 세 가지 관점(ex. 이상한 나라의 앨리스)

- **심볼**: 개념의 간단한 이름이나 표현.
  - ex. 트럼프
- **내연**: 개념의 완전한 정의로, 객체가 그 개념에 속하는지 결정하는 데 도움을 준다.
  - ex. 몸이 납작하고 두 손과 두 발은 네모 귀퉁에 달려 있는 인물
- **외연**: 그 개념에 속하는 모든 객체들의 집합.
  - ex. 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트왕과 여왕

### 타입(Type)
- 타입은 근복적으로 개념과 동일하다. 물론 SW에서 그대로 적용하기 쉽지 않지만
- 타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과한 것이다.

### 객체의 행동이 타입을 정의한다
- 객체와 타입의 대한 조언
  - 객체의 타입은 내부 구현이 아닌, 객체가 수행하는 **행동**에 따라 결정된다.
  - 내부 구조는 다르지만 동일한 행동을 하는 객체들은 동일한 타입에 속할 수 있다.
  - 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 
  - 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.

### 다형성  
> 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력
- 동일한 책임을 수행하는 일련의 객체는 동일한 타입이다.
- 행동만 동일(같은 타입)하다면 서로 다른 데이터를 가질 수 있다.
- 다형성을 유지하기 위해 동일한 메시지를 수신할 수 있어야 한다.

### 캡슐화
- 객체지향 설계는 인터페이스 뒤에 행동과 상태를 캡슐화하여, 객체의 내부 구현이 변경되더라도 외부와의 상호작용에 영향을 주지 않도록 한다.
  - 그렇지 않으면 객체의 분류 체계는 빠르게 오염된다. 

### 타입의 계층
- `일반화(generalization)` : 일반적인 타입의 모음
  - ex. 트럼프 카드의 특징 : 납작 엎드릴 수 있음, 뒤집어질 수 있음
- `특수화(specialization)` : 일반적인 타입이 가진 모든 타입을 포함하지만, 거기에 더 해 자신만의 특수한 타입이 포함됨
  - ex 트럼프 카드 인간의 특징 : 걷기, 말하기
- 일반화와 특수화는 동시에 일어난다.
- 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있다.(리스코프 치환의 원칙)
- `슈퍼타입(Supertype)` = 일반적인 타입, `서브타입(Subtype)` = 특수한 타입

### 정적 모델
- 동적으로 변하는 객체의 복잡성을 극복하기 위해 타입을 사용한다.
  - 객체의 상태가 변경해도 식별성은 동일하게 유지된다.
  - ex. 타입 모델(type diagram)

### 동적 모델
- 객체의 상태를 스냅샷 처럼 포착하는 것
  - ex. UML의 객체 다이어그램(object diagram)

### 클래스(class)
- 객체지향에서 정적인 모델은 클래스를 이용해서 구현된다.
  - 가장 보편적인 방법 but 클래스가 타입과 동일하지 않다.

## 4장: 역할, 책임, 협력
> 우리 모두를 합친 것보다 더 현명한 사람은 없다.(by 캔 블랜차드)

### 협력 (Collaboration)

#### 협력의 중요성

- **객체지향 시스템은 객체들의 협력으로 이루어진다.** 
  - 단일 객체는 시스템의 복잡한 기능을 수행할 수 없으며, 객체들은 서로 메시지를 주고받으며 공동의 목표를 달성해야 한다.
- **협력은 객체들이 역할을 수행하며 책임을 다하는 과정에서 이루어진다.** 
  - 협력을 통해 시스템의 기능이 구현되며, 객체 간의 상호작용은 시스템의 동적인 동작을 결정한다.

### 협력의 특징

- **요청과 응답**: 협력은 한 객체가 다른 객체에게 요청을 보내고, 그 요청에 대한 응답을 받는 형태로 이루어짐.
- **연쇄적인 메시지 전달**: 하나의 요청은 여러 객체들 사이의 연쇄적인 메시지 전달을 유발할 수 있다.
- **문맥에 따른 행동 결정**: 객체는 협력하는 문맥 내에서 어떤 행동을 해야 할지 결정하며, 이는 객체의 책임과 역할에 의해 좌우된다.

## 책임 (Responsibility)

### 책임의 정의

- **책임은 객체가 제공해야 하는 기능이나 정보, 또는 해야 하는 일들을 의미한다.**
- **객체의 책임은 객체의 공용 인터페이스를 결정하며, 다른 객체들이 그 객체와 상호작용하는 방식을 정의.**
- **책임은 객체지향 설계에서 가장 중요한 개념 중 하나이며, 적절한 책임의 분배는 시스템의 품질을 좌우한다.**

### 책임의 분류

1. **하는 것(Doing)**
    - 객체 스스로 수행하는 행동이나 작업.
    - 다른 객체의 행동을 시작시키는 것.
    - 다른 객체의 활동을 제어하고 조절하는 것.
2. **아는 것(Knowing)**
    - 객체 자신에 대한 정보.
    - 관련된 객체에 대한 정보.
    - 계산이나 유도할 수 있는 정보.

- 책임은 객체 외부에 제공할 수 있는 `공용 인터페이스(public interface)` 로 구성한다.
  - 이때 `공용 인터페이스`는 `doing` 과 `knowing` 의 목록이 된다.

### 책임 할당의 원칙

- **책임은 객체가 협력에 참여하는 이유를 명확히 표현할 수 있어야 한다.**
- **너무 추상적이거나 구체적인 책임은 피하고, 적절한 수준에서 객체의 역할과 협력 의도를 나타내야 한다다.**
- **객체의 자율성을 높이기 위해, 객체는 `무엇을(what)` 해야 하는지 알지만, `어떻게(how)` 수행할지는 객체 스스로 결정하도록 해야 한다다.**

## 역할 (Role)
> 책임의 집합이 의미하는 것
### 역할의 정의

- **역할은 객체가 특정한 협력 내에서 수행하는 책임의 집합을 의미.**
- **역할은 협력에서 대체 가능성을 나타내며, 여러 객체가 동일한 역할을 수행할 수 있다.**
- 역할은 객체지향 설계의 `단순성(simplicity)`, `유연성(flexibility)`, `재사용성(reusability)`를 뒷받친다.
- **역할을 통해 협력을 `추상화`하여, 시스템을 더 유연하고 `재사용 가능`하게 설계할 수 있다.**

### 역할의 특징
- **대체 가능성(Substitutability)**
    - 동일한 역할을 수행하는 객체들은 서로 대체될 수 있다.
    - 이는 객체들의 행위 호환성을 의미하며, 다형성의 기반이 된다.
- **행동의 유연성**
    - 역할은 객체의 책임을 묶은 것으로, 객체는 역할에 정의된 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
- **다중 역할 수행**
    - 하나의 객체가 여러 역할을 동시에 수행할 수 있다.
    - 이는 객체의 협력 범위를 확장하고, 시스템의 복잡성을 관리하는 데 도움이 된다.

### 역할을 이용한 협력의 추상화

- **역할은 협력을 추상화하여 다양한 객체들이 참여할 수 있게 한다.**
- 예를 들어, '판사-증인-변호사'와 같은 협력에서 '증인' 역할은 다양한 객체들로 대체될 수 있다.
- **이를 통해 협력을 단순화하고, 시스템의 유연성과 확장성을 높일 수 있다.**

## 역할, 책임, 협력의 관계

- **협력은 객체들이 역할을 수행하며 책임을 다하는 과정에서 이루어진다.**
- **객체는 협력 안에서 역할을 맡고, 그 역할에 적합한 책임을 수행한다.**
- **역할을 통해 협력을 구조화하고, 책임을 통해 객체의 인터페이스를 정의하며, 협력을 통해 시스템의 기능을 구현한다.**
- 협력이 먼저 설계되어야 한다. 그럼 자연스럽게 책임이 보이고 역할이 성립된다.

### 객체지향 설계 기법
1. 책임-주도 설계
2. 디자인 패턴
3. 테스트-주도 개발

#### `책임-주도 설계 (Responsibility-Driven Design, RDD)`
- 시스템의 기능을 객체들의 책임으로 분할하고, 그 책임을 수행할 적절한 객체를 찾아 역할을 부여한다.
- 객체의 책임이 먼저 결정되고, 객체는 그 책임을 수행하기 위해 필요한 상태와 행동을 갖추게 된다.
- 이는 시스템을 협력하는 객체들의 집합으로 바라보고 설계하는 방법.

#### 메시지와 협력

- 객체 간의 협력은 메시지를 통해 이루어집니다.
- 메시지는 객체에게 책임을 수행하도록 요청하는 수단이며, 객체는 메시지를 수신하여 적절한 행동을 수행한다.
- 객체는 메시지를 수신할 수 있다는 것은 해당 책임을 수행할 수 있다는 것을 의미한다.

#### 역할을 통한 유연한 설계

- 역할을 사용하면 협력을 추상화하여 다양한 객체들이 참여할 수 있게 된다.
- 이는 시스템의 확장성과 재사용성을 높이며, 변경에 유연한 구조를 제.
- 다형성은 역할을 수행하는 객체들이 동일한 메시지를 수신하고, 각자 적절한 방식으로 처리할 수 있게 한다.

#### `디자인 패턴 (Design Patterns)`

- 반복적으로 발생하는 문제에 대한 검증된 해결책을 패턴으로 정리한 것.
- 객체지향 설계에서 역할, 책임, 협력을 효과적으로 구현하기 위한 템플릿 제공.
- 디자인 패턴을 활용하면 설계의 품질과 재사용성을 높일 수 있다.

#### `테스트-주도 개발 (Test-Driven Development, TDD)`

- 테스트를 먼저 작성하고, 그 테스트를 통과하는 코드를 작성하는 개발 방식.
- 객체의 역할과 책임을 명확하게 정의하고, 인터페이스를 먼저 설계하는 데 도움이 된다.
- 객체 간의 협력을 테스트 코드로 검증함으로써 안정적인 시스템을 구축한다.

## 5장: 책임과 메시지
> 메시지를 따라라
5장은 객체지향 설계에서 책임과 메시지가 어떻게 상호작용하며 시스템의 유연성과 재사용성을 높이는지에 대해 다뤘다. 책임과 메시지를 중심으로 객체 간의 협력이 이루어지며, 이를 통해 객체지향의 본질을 이해할 수 있었다.

### 자율적인 객체의 책임
- 객체지향 공동체를 구성하는 기본 단위는 `자율적`인 객체다.

#### 책임의 정의

- 책임은 객체가 수행해야 하는 행동이나 제공해야 하는 정보이다.
- 객체의 책임은 객체의 공용 인터페이스를 구성하며, 외부 객체들이 해당 객체와 상호작용하는 방식을 결정한다.
- 책임이 적절하게 할당되면 시스템의 유지보수성과 확장성이 향상된다.

#### 책임의 유형

1. 하는 것 (Doing)
    - 객체가 직접 수행하는 행동이나 작업.
    - 다른 객체의 행동을 유발하거나 제어하는 역할.
2. 아는 것 (Knowing)
    - 객체 자신에 대한 정보나 관련된 객체에 대한 지식.
    - 계산이나 유도할 수 있는 정보.

#### 책임 할당의 원칙

- 책임은 객체가 협력에 참여하는 이유를 명확히 표현해야 한다.
- 너무 추상적이거나 구체적인 책임은 피하고, 적절한 수준에서 역할과 협력 의도를 나타내야 한다.
- 객체의 자율성을 높이기 위해 '무엇을' 해야 하는지 알지만, '어떻게' 수행할지는 객체 스스로 결정하도록 해야 한다.

### 메시지와 메서드

#### 메시지의 역할

- 객체가 다른 객체에게 접근할 수 있는 유일한 벙법은 요청을 전송하는 것뿐이다.
- 메시지는 객체 간의 상호작용을 위한 요청이다.
- 객체는 메시지를 통해 자신의 책임을 수행하도록 요청받는다.
- 메시지는 시스템의 동적인 동작(그렇다 `책임` 이다.)을 결정하며, 객체 간의 협력을 이끈다.

#### 메서드의 역할

- 메서드는 메시지를 내부적으로 처리하는 객체의 구체적인 구현이다.
- 메서드는 객체의 내부 상태를 변경하거나, 다른 객체에게 추가적인 메시지를 전송할 수 있다.
- 메서드는 객체의 인터페이스에 속하며, 외부에서 호출될 수 있다.

#### 메시지와 메서드의 관계

- 메시지는 메시지 이름(mesage name)과 추가 정보인 인자(argument)로 구성된다.
  - 예: `증언하라(어제, 왕국)`
- 수신자를 포함하면 메시지 전송이 된다.
  - 예: `모자장수,증언하라(어제, 왕국)`
- 객체는 메시지를 수신하면 해당 메시지에 맞는 메서드를 실행한다.
  - 먼저 요청이 처리할 수 있는 확인하고 그 다음에 자유롭게 선택해서 응답
- 메시지와 메서드는 객체의 책임과 직접적으로 연결된다.

### 다형성 (Polymorphism)

#### 다형성의 정의

- 다형성은 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 능력이다.
- 다형성을 통해 동일한 인터페이스를 공유하는 객체들이 다양한 방식으로 메시지를 처리할 수 있다.
  - 수신자를 `캡슐화` 시킬 수 있다.

#### 다형성의 이점

- 유연성과 확장성을 제공한다.
- 객체 간의 결합도를 낮추어, 시스템의 변경에 유연하게 대응할 수 있게 한다.
- 재사용성을 높여, 동일한 메시지를 다양한 객체에서 사용할 수 있게 한다.

#### 다형성의 구현

- 상속과 인터페이스를 통해 다형성을 구현할 수 있다.
- 객체는 자신의 타입에 맞는 메서드를 오버라이드하여 메시지를 처리한다.
- 송신자는 수신자의 정확한 타입을 알 필요 없이 메시지를 전송할 수 있다.
  - 다형성은 메시지의 축복이다.
  - 메시지는 송신자와 수신자 사이의 결합도로 낮춰서 `유연`하고 `재사용`이 용이하게 한다.

#### what/who 사이클
- 객체의 협력관계를 설계하는 기법
- 어떤 행위(what)을 할지 결정하면, 누가(who)가 그 행위를 할지 결정 -> 계혹 반복
  1. 결과적으로 협력의 문맥에서 필요한 메시지를 결정한다.(`what`)
  2. 수신하기 적합한 객체를 선택한다. (`who`)
  3. 그러고 수신된 메시지가 객체의 책임을 결정한다.
  4. 책임에 맞춰서 구현한다.(`how`)

### 인터페이스와 구현의 분리
> 믿고, 묻지 말고 시켜라

#### 인터페이스의 정의

- 인터페이스는 객체가 외부에 제공하는 메시지의 집합이다.  
  - 내부를 생각할 필요가 없다. 내부가 변경되어도 마찬가지다.
- 인터페이스는 객체의 공용 인터페이스를 구성하며, 객체 간의 상호작용을 정의한다.
- 인터페이스만 동일하면 객체(사용자)는 아무런 문제없이 상호작용이 가능하다.

##### 공용 인터페이스 : 외부에서 접근 가능한 공개된 인터페이스
##### 내부 인터페이스 : 내부에서만 접근 가능한 숨겨진 인터페이스(객체 자신만 이용, 사실상 구현)

#### 좋은 인터페이스의 원칙
1. 좀 더 추상적인 인터페이스 -> 수신자의 자율성이 보장된다. 
2. 최소 인터페이스 -> 불필요한 인터페이스는 노출시키지 마라.
3. 인터페이스와 구현 간에 차이가 있다는 점을 인식 -> 아래 참고
 
#### 구현(implementation)의 정의

- 구현은 인터페이스를 통해 메시지를 처리하는 구체적인 방법이다.(`how`)
- **구현은 객체의 내부 상태와 메서드의 로직을 포함하며, 외부에 노출되지 않는다.**

#### 인터페이스와 구현의 분리 원칙

- 인터페이스와 구현을 분리하면, 객체의 내부 변경이 외부에 영향을 미치지 않는다.
- 인터페이스는 안정적으로 유지되며, 구현은 자유롭게 변경할 수 있다.
- 캡슐화를 통해 객체의 자율성과 시스템의 안정성을 확보할 수 있다.(`정보 은닉`)

#### 캡슐화
- 객체지향의 세계에서 캡슐화는 2가지 관점이 있다.(근데 둘 다 비슷한 말인듯)
  - 상태와 행위의 캡슐화(= 데이터 캡슐화)
    - 객체가 자유롭게 행동하기 위해
  - 사적인 비밀의 캡슐화 
    - 외부의 객체가 내부 상태를 직접 관찰하거나 제어하지 못하게 막는 것

### 객체 자율성이 중요한 이유
- 협력이 이해하기 쉽고 변경에 유연해지기 때문이다. 즉, 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질(sw 품질)을 결정한다.
  1. 자율적인 책임은 협력을 단순하게 만든다.
  2. 자율적인 책임은 모자 장수(객체, 수신자)의 외부와 내부를 명확하게 분리한다.
  3. 책임이 자율적인 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.
  4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
  5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.
- `추상화가 쉬워지고, 결합도는 낮아지고, 응집도는 높아지며, 캡슐화가 증진되고, 인터페이스와 구현이 명확해지며, 설계가 유연하고 재사용성이 향상된다.`

## 요약

- 책임: 객체가 수행해야 하는 행동이나 제공해야 하는 정보로, 시스템의 기능을 구성한다.
- 메시지: 객체 간의 상호작용을 위한 요청으로, 메시지를 통해 책임이 수행된다.
- 다형성: 동일한 메시지에 대해 다양한 객체가 다르게 반응함으로써 유연성과 확장성을 제공한다.
- 인터페이스와 구현의 분리: 객체의 외부 인터페이스와 내부 구현을 분리하여 시스템의 안정성과 유지보수성을 높인다.

## 6장: 객체 지도

> 구조는 기능보다 변화에 안정적

**6장은 객체지향 설계에서 구조와 기능의 관계를 다루며, 변화에 강한 시스템을 설계하기 위한 접근법을 제시한다. 안정적인 구조를 기반으로 시스템을 설계함으로써 기능의 변화에도 유연하게 대응할 수 있는 방법을 설명한다.**

### 핵심 개념

- **구조**는 시스템의 안정적인 요소이며, **기능**은 자주 변경되는 요소이다.
- 객체지향 설계에서는 자주 변경되는 기능보다 변화에 강한 구조를 먼저 설계해야 한다.
- **도메인 모델**과 **유스케이스**를 통합하여 책임-주도 설계를 실현한다.

### 기능 설계 vs 구조 설계
- 기능(funcion) 설계 : 제품이 사용자를 위해 무엇을 할 것인지.
  - 사용자에게 요구사항의 충분조건
- 구조(structure) 설계 : 제품의 형태가 어떠해야 하는지가 초점 
  - 사용자아게 요구사항의 필요조건

### 변화에 강한 구조 설계
- 그러나 사용자의 요구사항은 항상 변경된다.

#### 안정적인 구조의 중요성

- 소프트웨어 시스템은 시간이 지남에 따라 요구사항이 변화하기 마련이다.
- 변화에 유연하게 대응하기 위해서는 시스템의 **구조**가 안정적이어야 한다.
- 구조가 안정적일수록 새로운 기능의 추가나 변경이 용이해진다.

#### 구조와 기능의 분리

- **기능**은 사용자 요구사항에 따라 자주 변경되며, 시스템의 행동을 정의한다.
- **구조**는 시스템의 기본적인 틀을 형성하며, 기능의 변화를 흡수할 수 있도록 설계되어야 한다.
- 구조와 기능을 분리하여 설계하면 기능 변경 시 구조의 영향을 최소화할 수 있다.

### 도메인 모델과 유스케이스의 통합
- `도메인(domain)` : 사용자가 프로그램을 사용하는 대상 분야
  - 도메인 모델링 : 구조를 수집하고 표현하기 위한 기법
- `유스케이스(usecase)`
  - 유스케이스 모델링 : 기능을 수집하고 표현하기 위한 기법

#### 도메인 모델 (Domain Model)

- **도메인 모델**은 시스템이 다루는 영역의 개념과 관계를 표현한 것이다. 
  - 참고 : 도널드 노먼의 멘탈 모델의 세가지 측면
    - 사용자 모델(사용자): 사용자가 제품에 대해 갖고 있는 개념들의 모습
    - 디자인 모델(디자이너): 설계자가 마음 속에 갖고 있는 시스템에 대한 개념화
    - 시스템 이미지(시스템): 실제 제품
- 도메인 모델은 비즈니스 규칙과 정책을 반영하며, 시스템의 핵심 개념을 안정적으로 유지한다.
- 도메인 모델을 통해 객체의 역할과 책임을 정의한다.
- 객체지향은 사용자가 이해하는 도메인 구조와 최대한 비슷하게 코드를 구조화할 수 있다.
  - 연결완정성 또는 표현적 차이라고 한다.(2장의 `은유`개념)

#### 유스케이스 (Use Case)

- **유스케이스**는 사용자의 목표를 달성하기 위해 시스템과 상호작용하는 시나리오를 정의한다.
- 유스케이스는 시스템이 제공해야 하는 기능을 명확히 하며, 기능의 흐름을 이해하는 데 도움을 준다.
- 유스케이스를 통해 시스템이 수행해야 하는 기능을 식별하고, 이를 책임으로 변환한다.

#### 유스케이스의 특성
1. 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 '텍스트'다.
2. 유스케이스는 여러 시나리오의 집합니다.
3. 유스케이스는 단순한 피처(feature) 목록과 달리, 이야기를 통해 연관된 기능들을 함께 묶는다.
4. 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.
5. 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.
   - [참고](https://www.cs.otago.ac.nz/coursework/cosc461/usecases.htm)

#### 책임-주도 설계 (Responsibility-Driven Design)

- 책임-주도 설계는 도메인 모델과 유스케이스를 통합하여 시스템의 객체들을 설계하는 방법이다.
- 유스케이스를 통해 기능을 정의하고, 도메인 모델을 통해 기능을 수행할 객체의 역할과 책임을 식별한다.
- 이 과정을 통해 시스템의 구조와 기능을 통합적으로 설계한다.

### 설계의 원칙

#### 변화에 대비하는 설계

- **미래의 변경을 예측하기 어렵기 때문에**, 변경을 수용할 수 있는 설계를 우선시해야 한다.
- 구조는 변하지 않는 요소로 설계하고, 기능은 변할 수 있는 요소로 설계한다.
- **개방-폐쇄 원칙(Open-Closed Principle)**을 적용하여, 시스템은 확장에 열려 있고 수정에 닫혀 있어야 한다.

#### 추상화와 캡슐화

- **추상화**는 복잡성을 줄이고, 중요한 개념을 강조하여 설계의 안정성을 높인다.
- **캡슐화**는 객체의 내부 상태와 구현을 숨기고, 인터페이스를 통해 상호작용하도록 한다.
- 이를 통해 시스템의 구조를 안정적으로 유지하고, 기능의 변화를 유연하게 수용할 수 있다.

### 요약

- 객체지향 설계에서 **구조**는 안정적인 요소로, **기능**은 변화하는 요소로 간주한다.
- **도메인 모델**과 **유스케이스**를 통합하여 책임-주도 설계를 실현함으로써, 변화에 강한 시스템을 설계할 수 있다.
- **추상화**와 **캡슐화**를 통해 시스템의 구조를 안정적으로 유지하고, 기능의 변화를 유연하게 수용할 수 있다.
- 변화에 대비하는 설계 원칙을 적용하여, 유지보수성과 확장성이 높은 객체지향 시스템을 구축한다.

## 7장: 함께 모으기
> 3가지 관점과 커피 전문점 도메인 설계 예제

7장은 객체지향 설계에서 중요한 세 가지 관점인 `개념 관점`, `명세 관점`, `구현 관점`을 소개하고, 이를 바탕으로 커피 전문점 도메인 설계를 예제로 설명한다. 이 장을 통해 객체지향 설계의 다양한 관점을 이해하고, 실제 설계에 적용하는 방법을 배울 수 있다.

### 개념 관점 (Conceptual Perspective)

#### 개념 관점의 정의

- 개념 관점은 도메인 내 존재하는 개념과 개념들 간의 관계를 표현한다.
  - 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심
- 시스템이 다루는 주요 개념들을 식별하고, 이들 간의 연관성을 정의한다.
- 예시: 커피 전문점 도메인에서 고객(Customer), 주문(Order), 바리스타(Barista), 메뉴(Menu) 등이 주요 개념에 해당한다.

#### 개념 관점의 중요성

- 도메인 지식을 명확히 이해하고 표현하는 데 도움을 준다.
- 시스템의 핵심 개념을 안정적으로 유지하며, 변경에 강한 구조를 설계할 수 있게 한다.
- 개념 간의 관계를 명확히 함으로써 협력 구조를 효과적으로 구축할 수 있다.

### 명세 관점 (Specification Perspective)

#### 명세 관점의 정의

- 명세 관점은 실제 SW의 객체들의 책임에 초점
  - 객체가 협력을 위해 `무엇`을 할 수 있는지를 정의한다.
- 객체의 공용 인터페이스를 설계하여, 어떤 메시지를 수신할 수 있는지를 명확히 한다.
  - class의 인터페이스를 바라본다.
- 예시: 주문(Order) 객체는 `추가메뉴(MenuItem)`, `삭제메뉴(MenuItem)`, `계산하기(CalculateTotal)` 등의 메서드를 가질 수 있다.

#### 명세 관점의 중요성

- 객체 간의 상호작용을 명확히 정의함으로써 협력의 기반을 마련한다.
- 인터페이스를 통해 객체의 역할과 책임을 명확히 하여, 협력 구조의 일관성을 유지한다.
- 객체의 재사용성과 유연성을 높인다.

### 구현 관점 (Implementation Perspective)

#### 구현 관점의 정의

- 구현 관점은 객체가 책임을 수행하기 위해 필요한 실제 코드를 작성하는 것을 의미한다.
- `how`인 객체의 내부 동작과 상태 관리를 구현하며, 인터페이스를 통해 외부와 상호작용한다.
- 예시: 바리스타(Barista) 객체는 `커피만들기(MakeCoffee)` 메서드를 구현하여, 주문에 따라 커피를 제조한다.

#### 구현 관점의 중요성

- 객체의 책임을 실제로 수행할 수 있게 한다.
- 내부 구현을 통해 객체의 행동을 구체화하며, 외부에는 인터페이스만 노출시킨다.
- 변경에 유연하게 대응할 수 있도록 내부 구현을 캡슐화하여 외부에 영향을 미치지 않는다.

### 커피 전문점 도메인 설계 예제

#### 설계 과정

1. 협력 설계의 목표 설정
    - 시스템의 주요 기능을 정의하고, 이를 수행하기 위한 객체들의 협력 구조를 설계한다.
2. 역할과 책임 할당
    - 각 객체가 맡을 역할과 수행할 책임을 명확히 정의한다.
    - 예시: 고객(Customer)은 주문(Order)을 생성하는 역할을 맡고, 바리스타(Barista)는 주문을 처리하는 책임을 가진다.
3. 메시지 중심의 협력 구조 설계
    - 객체들이 주고받을 메시지를 정의하고, 이를 통해 협력 구조를 구축한다.
    - 예시: 고객이 주문을 생성하면, 주문 객체는 바리스타에게 커피 제조를 요청하는 메시지를 보낸다.
4. 인터페이스와 구현 분리
    - 객체의 공용 인터페이스를 정의하고, 이를 통해 내부 구현을 캡슐화한다.
    - 예시: 바리스타는 `커피만들기(MakeCoffee)` 인터페이스를 통해 커피를 제조하며, 내부적으로는 다양한 커피 제조 방식을 구현할 수 있다.

#### 설계 예제의 특징

- 역할, 책임, 협력을 중심으로 설계됨으로써 유연하고 확장 가능한 구조를 갖춘다.
- 다형성을 활용하여 바리스타 객체가 다양한 커피 제조 방식을 유연하게 처리할 수 있다.
- 인터페이스와 구현의 분리를 통해 시스템의 유지보수성과 확장성을 높인다.

### 인터페이스와 구현의 분리 재강조

#### 인터페이스의 역할

- 객체가 외부에 제공하는 메시지의 집합을 정의한다.
- 인터페이스를 통해 객체 간의 상호작용을 명확히 하고, 내부 구현을 숨긴다.

#### 구현의 역할

- 인터페이스를 통해 정의된 메시지를 실제로 처리하는 방법을 구현한다.
- 구현은 객체의 내부 상태와 동작을 관리하며, 외부에는 노출되지 않는다.

#### 분리의 중요성

- 인터페이스와 구현을 분리함으로써, 내부 구현의 변경이 외부에 영향을 미치지 않게 된다.
- 시스템의 안정성을 유지하고, 변경에 유연하게 대응할 수 있게 한다.
- 캡슐화를 통해 객체의 자율성과 협력 구조의 일관성을 보장한다.

### 요약

- 개념 관점, 명세 관점, 구현 관점의 세 가지 관점을 통해 객체지향 설계를 다각도로 이해하고 적용할 수 있다.
- 커피 전문점 도메인 설계 예제를 통해 실제 설계 과정에서 역할, 책임, 협력의 개념을 어떻게 적용하는지를 학습할 수 있다.
- 인터페이스와 구현의 분리를 통해 시스템의 유지보수성과 확장성을 높이고, 변화에 강한 구조를 설계할 수 있다.
- 책임-주도 설계를 통해 시스템의 기능을 객체들의 책임으로 분할하고, 이를 통해 유연하고 견고한 객체지향 시스템을 구축할 수 있다.

