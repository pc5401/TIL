# 플라이웨이트 (Flyweight Patterns)

오늘 얄코님의 [플라이웨이트 (Flyweight Patterns) 강의](https://www.youtube.com/watch?v=nNO3CV91OrI&t=231s)가 있어서 내 나름대로 정리해본다.

플라이웨이트(Flyweight) 패턴은 동일한 속성을 가진 객체를 여러 번 생성하는 대신, 이미 생성된 객체를 공유하여 메모리 사용을 절약하는 패턴이다. 객체가 많을 때, 특히 속성의 값이 같다면 이를 새로 만들지 않고 재사용하는 것이 이 패턴의 핵심이다.


## 예시 코드
``` typescript
class Book {
  constructor(public title: string) {}

  read() {
    console.log(`Reading: ${this.title}`);
  }
}

class Bookshelf {
  private static books: Map<string, Book> = new Map();

  static getBook(title: string): Book {
    if (!this.books.has(title)) {
      console.log(`Creating new instance for: ${title}`);
      const book = new Book(title);
      this.books.set(title, book);
    } else {
      console.log(`Reusing existing instance for: ${title}`);
    }
    return this.books.get(title)!;
  }
}

// 클라이언트 코드
const book1 = Bookshelf.getBook('Effective TypeScript');
book1.read(); // 새로운 책 생성

const book2 = Bookshelf.getBook('Effective TypeScript');
book2.read(); // 기존 책 재사용

const book3 = Bookshelf.getBook('Clean Code');
book3.read(); // 새로운 책 생성
```

**결과**:

1. `Effective TypeScript`라는 책은 처음에는 새로운 인스턴스로 생성되고, 두 번째 호출에서는 재사용된다.
2. `Clean Code`라는 책은 처음 생성되므로 새로운 인스턴스가 생성된다.


## **플라이웨이트 패턴 마무리**:

- **의도**: 많은 객체가 필요한 상황에서, 동일한 데이터를 공유할 수 있는 객체들만 공유하여 **메모리를 절약**하는 데 초점을 둔다.
- **구조**: 여러 인스턴스가 존재할 수 있지만, 동일한 속성을 가진 객체들만 공유된다. 즉, 모든 객체가 아니라 필요한 객체만 재사용합니다.
- **적용 예시**: 문자열, 폰트, UI 컴포넌트 등과 같이 같은 속성을 가진 객체를 많이 생성해야 하는 경우에 사용된다.

## 참고 : 다른 패턴과 비교

### 1. **플라이웨이트 패턴 vs. 싱글톤 패턴**

- **목적**:
    - **플라이웨이트**: **여러 객체** 중 **같은 속성을 가진 객체**를 공유하여 메모리를 절약하려는 목적.
    - **싱글톤**: **애플리케이션 전체**에서 단 **하나의 인스턴스**만 존재하도록 보장하려는 목적.
- **사용 상황**:
    - **플라이웨이트**: **반복되는 객체**가 많을 때, 메모리 관리 효율성을 위해 사용.
    - **싱글톤**: **하나의 객체**만 있어야 하거나, 그 객체가 **전역적으로 공유**되어야 할 때 사용.
- **인스턴스 수**: 플라이웨이트는 여러 인스턴스를 관리하지만, 동일한 속성을 가진 객체만 공유. 싱글톤은 인스턴스가 **하나**만 존재함.

### 2. **플라이웨이트 패턴 vs. 팩토리 패턴**

- **목적**:
    - **플라이웨이트**: **이미 존재하는 객체를 재사용**하는 데 중점을 둠.
    - **팩토리**: 객체 생성 로직을 **추상화**하여 **객체 생성을 책임지는** 역할.
- **사용 상황**:
    - **플라이웨이트**: **많은 객체**가 만들어지지만, 그중 **중복된 객체**를 재사용하고자 할 때 사용.
    - **팩토리**: **객체 생성**을 클라이언트 코드와 분리하고 싶을 때 사용.
- **인스턴스 관리**: 플라이웨이트는 메모리 절약을 위해 객체를 재사용하는 데 집중. 팩토리 패턴은 객체 생성을 관리하지만, 객체가 **재사용되는지에 대한 관여는 없음**.

### 3. **플라이웨이트 패턴 vs. 프로토타입 패턴**

- **목적**:
    - **플라이웨이트**: 메모리를 절약하기 위해 **이미 존재하는 객체를 재사용**함.
    - **프로토타입**: **기존 객체를 복제**하여 새 객체를 생성.
- **사용 상황**:
    - **플라이웨이트**: **중복된 데이터**를 가진 객체가 많이 생성될 때 그 객체들을 공유하기 위해 사용.
    - **프로토타입**: **기존 객체를 그대로 복제**하는 방식으로 새로운 객체를 만들고자 할 때 사용.
- **인스턴스 관리**: 플라이웨이트는 **동일한 인스턴스**를 재사용하는 반면, 프로토타입은 **새로운 객체를 복제**하여 메모리 사용을 최적화하지는 않음.

### 4. **플라이웨이트 패턴 vs. 객체 풀 패턴**

- **목적**:
    - **플라이웨이트**: **같은 속성**을 가진 객체를 재사용하여 메모리 사용을 최적화.
    - **객체 풀**: 객체를 **미리 생성해 풀(pool)에 저장**하고 필요할 때 **재사용**하여 자원 소모를 줄임.
- **사용 상황**:
    - **플라이웨이트**: 많은 **유사 객체**를 재사용하는 경우 사용.
    - **객체 풀**: **비싼 자원을 사용하는 객체**를 미리 만들어두고, 필요할 때 재사용하는 경우 사용. 예: 데이터베이스 연결 객체.
- **인스턴스 관리**: 객체 풀은 미리 만들어진 객체를 재사용하는 반면, 플라이웨이트는 **중복된 속성**을 가진 객체만 재사용하는 데 집중.

### 5. **플라이웨이트 패턴 vs. 데코레이터 패턴**

- **목적**:
    - **플라이웨이트**: 객체를 **재사용**하고 메모리를 절약.
    - **데코레이터**: 객체에 **새로운 기능을 동적으로 추가**함.
- **사용 상황**:
    - **플라이웨이트**: **반복적으로 같은 속성**을 가진 객체가 많이 만들어질 때 메모리 절약을 위해 사용.
    - **데코레이터**: 객체에 **새로운 책임을 추가**하고 기능을 확장할 때 사용.
- **인스턴스 관리**: 플라이웨이트는 **중복된 객체**를 공유하고, 데코레이터는 **객체에 새로운 행동**을 추가하는 데 중점을 둠.